---
title: I/O多路复用——了解Linux I/O模型
description: 聊一聊多路复用问题所涉及的Linux I/O模型。
date: 2024-01-27 01:02:43
tags:
  - 服务端
  - Linux
  - 计算机网络
categories: 
  - 技术
plugins:
  - indent
  - snackbar: updating
---

## 简述

### 面试相关

I/O多路复用问题算是服务端开发面试中一个比较常见的问题，在牛客以“多路复用”为关键词搜索可以找到不少面经，大概有这么几个问题：

- 基本问题，例如介绍多路复用/比较几种I/O模型/多路复用的优缺点等等
- HTTP的多路复用
  > 显然这个问题与本文没啥关系，HTTP的多路复用是指HTTP/2的多路复用，HTTP/2的多路复用是基于TCP的，而本文讨论的多路复用是指Linux的多路复用，是基于文件描述符的。
- select/poll/epoll的区别
  > 这个问题其实是对多路复用的实现方式的问题，本文会在后面详细讨论。
- 使用了多路复用机制的常见中间件，例如Redis、Nginx等等。

要应付面试中的这些问题，笔者认为需要掌握的内容并不算很多，而且比较有条理。个人建议准备一下内容：

1. 介绍多路复用的概念，以及多路复用的优缺点。
2. 熟悉Linux的I/O模型，以及select/poll/epoll的区别，包括BIO、NIO、AIO的区别。
3. 能够以Redis、Netty等常见中间件为例，介绍多路复用的使用场景。

### I/O基本问题

在开始本文的内容前，我们需要先了解“I/O”的一系列相关知识。

首先，I/O操作是编程时经常会遇到的问题，I/O操作的本质是数据的输入和输出，例如从文件中读取数据、向文件中写入数据、从网络中读取数据、向网络中写入数据等等。I/O操作的本质是数据的输入和输出，而数据的输入和输出是需要时间的，因此I/O操作是一个耗时的操作，而且I/O操作的耗时是不确定的，这是因为I/O操作的耗时与I/O设备的性能、I/O设备的负载、I/O操作的数据量等等都有关系。

在计算机组成原理课程中，应该比较过I/O设备与CPU的速度差异，I/O设备的速度远远低于CPU的速度，因此CPU在执行I/O操作时，会出现等待的情况，这种情况称为“阻塞”。阻塞的情况下，CPU会一直等待I/O操作完成，这样CPU的时间就浪费了。因此，各种I/O模型要解决的问题就是如何让CPU在I/O操作时不阻塞，而是去做其他的事情。

首先，在硬件层面上已经有DMA等技术来解决这个问题，，而在软件层面上，我们可以通过多线程、多进程、多路复用等技术来解决这个问题，这些技术都是在软件层面上解决的，而且这些技术都是通用的。

其中，多路复用是一种比较常见的技术，它的本质是通过一个线程来监听多个文件描述符，当某个文件描述符就绪时，就通知线程，线程就可以去处理这个文件描述符了。多路复用的优点是可以减少线程的数量，从而减少线程切换的开销，提高CPU的利用率，而且多路复用的实现方式是通用的，可以用于各种I/O设备，例如文件、网络等等。

为了更好的学习相关技术，我们还需要引入同步/异步、阻塞/非阻塞等概念。

#### 同步与异步

同步（Synchronous）与异步（Asynchronous）是指I/O操作的调用方式。

在同步操作中，I/O操作的调用者会一直等待I/O操作完成在执行后面的操作，而在异步操作中，I/O操作的调用者不会等待I/O操作完成，而是通过回调函数等方式来处理I/O操作的结果。同步与异步的区别在于使用一个指令进行I/O操作时，指令的执行者是否需要等待I/O操作完成。以下面这段伪代码为例：

```c
// 同步操作
result = do_io();
// 处理result

// 异步操作
do_io(callback);
// 其他操作
```

在同步操作中，指令的执行者会一直等待I/O操作完成，也就是`do_io()`函数的调用者会一直等待`do_io()`函数执行完成，然后执行`// 处理result`这一行代码。而在异步操作中，`do_io()`函数的调用者不会等待`do_io()`函数执行完成，而是直接执行`// 其他操作`这一行代码，当`do_io()`函数执行完成后再执行`callback`函数。

#### 阻塞与非阻塞

阻塞（Blocking）与非阻塞（Non-blocking）是指I/O操作的执行方式。

在阻塞操作中，CPU会一直等待I/O操作完成，而在非阻塞操作中，CPU不会等待I/O操作完成，而是去做其他的事情。阻塞/非阻塞描述的是进行IO操作时处理机的状态，对于一个同步操作而言，该操作有可能是阻塞也可能是非阻塞的，而对于一个异步操作而言，该操作一定是非阻塞的。

对于一个阻塞等待的操作，CPU会一直等待，直到IO操作完成才继续执行后续代码。在阻塞状态下，程序无法进行其他任务，会一直停留在等待IO操作的过程中。

#### 文件描述符

Linux的I/O操作是通过文件描述符来实现的，文件描述符是一个非负整数，它是一个索引值，指向内核中的一个打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，文件描述符是一个抽象概念，它是一个与具体I/O设备无关的抽象概念，它可以指向任何类型的I/O设备，例如文件、网络等等。

### I/O多路复用介绍

通过前面的介绍，我们应该认识到“同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态”这个基本的概念。而多路复用是一种**同步、非阻塞**的I/O模型，它的本质是通过一个线程来监听多个文件描述符，当某个文件描述符就绪时，就通知线程，线程就可以去处理这个文件描述符了。

对于一次IO的过程，我们还需要知道在Linux中文件、网络都是以文件描述符的形式存在的。当我们打开一个文件时，内核会返回一个文件描述符，当我们打开一个网络连接时，内核也会返回一个文件描述符。而IO操作获得的数据也并不是直接返回给用户的，而是先写入内核的缓冲区，然后再从内核的缓冲区中读取数据。因此，我们可以把IO操作分为两个阶段：

1. 等待数据准备好
2. 将数据从内核缓冲区拷贝到用户缓冲区

多路复用关心的是第一个阶段，也就是等待数据准备好的阶段，而第二个阶段是由用户线程来完成的。

引入多路复用技术后，原本需要一个独立线程来完成的一个普通的同步阻塞IO操作，现在可以通过一个线程来完成多个IO操作，这样就减少了线程的数量，从而减少了线程切换的开销，提高了CPU的利用率。

## Linux I/O模型

Linux中共有5种I/O模型，分别是：

- 阻塞I/O（Blocking I/O）
- 非阻塞I/O（Non-blocking I/O）
- I/O复用（I/O multiplexing）
  > 包括select、poll、epoll。
- 信号驱动I/O（Signal driven I/O）
  > 信号驱动I/O是一种比较少见的I/O模型，本文不会详细介绍，典型的应用是SIGIO信号。
- 异步I/O（Asynchronous I/O）
  > POSIX的`aio_`系列函数。

> 另一种常常遇到的说法（AIO、BIO、NIO）本身并不准确。AIO、BIO和NIO是Java中的概念，本文讨论的是Linux的I/O模型，因此本文不会使用AIO、BIO和NIO这些概念，但会在后面的内容中介绍Java中的AIO、BIO和NIO。

实际应用中，我们常常会使用多种I/O模型，例如Nginx中就同时使用了阻塞I/O和I/O复用，而Redis中则同时使用了阻塞I/O、I/O复用和异步I/O。

### Blocking I/O

![Blocking I/O](https://s2.loli.net/2024/02/01/xbU5Sa7i2khyeIL.png)

阻塞IO顾名思义，当程序向 Kernel 发起 System call `read()`时，进程此时阻塞，等待数据就绪(Kernel 读取数据到 Kernel space)。

对于本地磁盘IO，Blocking IO性能不会有太大问题；但是对于Socket IO，由于Socket数据的传输速度远低于本地磁盘，因此线程不得不长时间等待数据的到来。在这种I/O模型下，我们不得不为每一个Socket都分配一个线程，这会造成很大的资源浪费。

### Non-blocking I/O

![Non-Blocking I/O](https://s2.loli.net/2024/02/01/bXwJsTFetKy1f82.png)

相对于阻塞I/O在那傻傻的等待，非阻塞I/O隔一段时间就发起 System call 看数据是否就绪(`ready`)。如果数据就绪，就从 Kernel space 复制到 user space，操作数据; 如果还没就绪，Kernel 会立即返回`EWOULDBLOCK`这个错误。

Non-blocking I/O的优势在于，进程发起I/O操作时，不会因为数据还没就绪而阻塞，这就是”非阻塞”的含义。但这种I/O模型缺陷过于明显。在本地I/O，Kernel 读取数据很快，这种模式下多了至少一次 System call，而 System call 是比较消耗CPU的操作。对于Socket而言，大量的 System call 更是这种模型显得很鸡肋。

### I/O Multiplexing

I/O Multiplexing 就是本篇文章的重头戏——多路复用了。

I/O Multiplexing 首先向 Kernel 发起 System call，传入 File descriptor 和感兴趣的事件(`readable`、`writable`等)让 Kernel 监测，当其中一个或多个`fd`数据就绪，就会返回结果，程序再发起真正的I/O操作`recvfrom`读取数据。

在监听方式上，也就是发起的这个 System Call 共有三种：`select`、`poll`和`epoll`，接下来分别讨论他们。

### Signal Driven I/O

### Asynchronous I/O
