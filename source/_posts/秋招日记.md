---
title: 秋招日记
description: 秋招日记
keywords: [秋招, 后端, 服务端, 客户端, 算法, 面试]
headimg: https://image.thuray.xyz/2024/07/de46f9b19513f5e7d1b102aa06305dd5.jpg
date: 2024-07-14 14:46:18
tags: 
  - 服务端
  - 客户端
  - 算法
  - LeetCode
categories: 
  - 求职
plugins:
  - indent
  - snackbar: updating
---

## 小结

## 日记

### Template

#### 算法

试图搞定今天的每日一题[721. 账户合并](https://leetcode.cn/problems/accounts-merge/description/)，但并没有研究明白怎么做，看一眼提示才发现是并查集，算法课上学的忘干净了。

> 并查集：一种树形的数据结构，用于处理一些不交集的集合的合并及查询问题。并查集支持两种操作：
>
> - `Find`：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集。
> - `Union`：将两个子集合并成同一个集合。
>
> 在这道题中，我们可以使用并查集来维护每个邮箱属于哪个账户。对于每个账户，我们将该账户的第一个邮箱作为“代表”邮箱，然后遍历该账户的所有邮箱，将其与代表邮箱进行合并。

代码好长，学不明白。

#### 八股

#### 语言

#### 摸鱼

今天先看了一点推荐系统的内容，包括这个仓库[solidglue/Recommender_System](https://github.com/solidglue/Recommender_System/)，第一部分是王树森的推荐系统公开课[wangshusen/RecommenderSystem](https://github.com/wangshusen/RecommenderSystem)，但是还没仔细看。

顺便发现了一个仓库[gorse](https://github.com/gorse-io/gorse)，Go 实现的一个推荐系统，分布式架构（区分了Worker、Master、API Server），支持基于协同过滤的推荐算法，看起来适合学习。

关于 Dify，尝试将 Notion 导入到知识库中时，发现除了`Embedding`模型，还需要一个`Reranker`模型进行召回的综合排序（包括关键词召回和向量召回），关于`Reranker`模型目前常用的应该是[cohere](https://cohere.com/)和[Jina](https://jina.ai/)。

### 07-14

#### 算法

今天不求别的，只求把[股票买卖](https://labuladong.online/algo/dynamic-programming/stock-problem-summary/)研究明白。

> 这问题真那么难吗？
> 真难，写不明白。

感觉好像明白了一点，看看明天还能不能品出来吧。模板放在这里。

```c++
class Solution {
private:
    int maxProfit_all_in_one(int max_k, vector<int>& prices, int cooldown, int fee) {
        int n = prices.size();
        if (n <= 0) {
            return 0;
        }
        // WARN 处理max_k过大，等价于不限制操作次数的情况
        if (max_k > n / 2) {
            return maxProfit_k_inf(prices, cooldown, fee);
        }

        vector<vector<vector<int>>> dp(n, vector<vector<int>>(max_k + 1, vector<int>(2)));
        // base_case: k为0，即不能进行交易
        for (int i = 0; i < n; i++) {
            dp[i][0][0] = 0;
            dp[i][0][1] = INT_MIN;
        }

        for (int i = 0; i < n; i++) {
            for (int k = 0; k <= max_k; k++) {
                // 还没有开始交易
                if (i <= 0) {
                    dp[i][k][0] = 0;
                    dp[i][k][1] = INT_MIN;
                    continue;
                }

                if (i - cooldown <= 0) {
                    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                    dp[i][k][1] = max(dp[i-1][k][1], -prices[i] - fee);
                } else {
                    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                    dp[i][k][1] = max(dp[i-1][k][1], dp[i - cooldown - 1][k - 1][0] - prices[i] - fee);
                }
            }
        }

        return dp[n-1][max_k][0];
    }

    int maxProfit_k_inf(vector<int>& prices, int cooldown, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));

        for (int i = 0; i < n; i++) {
            // 还没有开始交易
            if (i <= 0) {
                dp[i][0] = 0;
                dp[i][1] = -prices[i] - fee;
                continue;
            }

            if (i - cooldown <= 0) {
                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
                dp[i][1] = max(dp[i-1][1], -prices[i] - fee);
            } else {
                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
                dp[i][1] = max(dp[i-1][1], dp[i - cooldown - 1][0] - prices[i] - fee);
            }
            
        }

        return dp[n-1][0];
    }

public:
    int maxProfit(vector<int>& prices) {
        return maxProfit_all_in_one(prices.size(), prices, 0, 0);
    }
};
```

#### 八股

今天没看。

#### 语言

研究了一下 Go（Gin）的参数绑定，自动参数绑定使用反射还是比较多，也可以利用Go的元编程特性，自动生成参数绑定的代码，但是这样会导致代码可读性下降。大概搜到这几篇文章看看：

- [](https://www.51cto.com/article/720688.html)
- [](https://juejin.cn/post/6844904033551908871)

Gin 本身`ShoundBind`算是有 Go 策略模式的实现，择日细学。

#### 摸鱼

Bravo 还没开始，学了一点`Next.js`和PWA，SSR 组件还是很难直接上手，需要系统学一遍Next。

### Template

#### 算法

#### 八股

#### 语言

#### 摸鱼
